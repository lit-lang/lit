type TestRunner {
  init {
    self.tests = []
    self.current_group = nil
  }

  fn test { |name, block|
    self.tests.push({ name: name, block: block })
  }

  fn describe { |group_name, group_block|
    self.current_group = group_name
    group_block(self)
    self
  }

  fn run {
    let start_time = clock()
    var failed_tests = []
    var tests_without_assertions = []

    self.tests.each(fn { |t|
      let result = t[:block](Should())

      if result && result[:ok] == false {
        print("F")
        failed_tests.push({ name: "{self.current_group} {t[:name]}", message: result[:message] })
      } else {
        if result {
          print(".")
        } else {
          print("?")
          tests_without_assertions.push(t[:name])
        }
      }
    })

    println()

    failed_tests.each(fn { |f|
      println()
      println("{f[:name]}:")
      println("  {f[:message]}")
    })
    let end_time = clock()
    let elapsed = end_time - start_time
    var total_time = if elapsed < 1 do "{elapsed * 1000}ms" else do "{elapsed}s"

    println()
    println("Finished in {total_time}")
    print("{self.tests.size()} examples, {failed_tests.size()} failures")
    if tests_without_assertions.size() > 0 {
      println(", {tests_without_assertions.size()} without assertions")
    } else {
      println()
    }

    let status = if failed_tests.is_empty?() do 0 else do 1
    exit(status)
  }
}

type Should {
  init {
    self.negated = false
  }

  fn not {
    let s = Should()
    s.negated = !self.negated
    return s
  }

  fn eq { |actual, expected|
    let ok = actual == expected

    if self.negated {
      if ok {
        return self.fail("Did not expect {inspect(expected)}, but got {inspect(actual)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(expected)}, but got {inspect(actual)}")
      }
    }

    return self.pass()
  }

  fn greater_than { |actual, value|
    let ok = actual > value

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be greater than {inspect(value)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be greater than {inspect(value)}")
      }
    }

    return self.pass()
  }

  fn greater_than_or_equal { |actual, value|
    let ok = actual >= value

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be >= {inspect(value)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be >= {inspect(value)}")
      }
    }

    self.pass()
  }

  fn less_than { |actual, value|
    let ok = actual < value

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be less than {inspect(value)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be less than {inspect(value)}")
      }
    }

    self.pass()
  }

  fn less_than_or_equal { |actual, value|
    let ok = actual <= value

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be <= {inspect(value)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be <= {inspect(value)}")
      }
    }

    self.pass()
  }

  fn be_in { |item, collection|
    self.include(collection, item)
  }

  fn include { |collection, item|
    let ok = collection.includes?(item)

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(collection)} to not include {inspect(item)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(collection)} to include {inspect(item)}")
      }
    }

    self.pass()
  }

  fn have_size { |actual, expected_size|
    let len = actual.size()
    let ok = len == expected_size

    if self.negated {
      if ok {
        return self.fail("Expected size to not be {expected_size}, but got {len}")
      }
    } else {
      if !ok {
        return self.fail("Expected size {expected_size}, got {len}")
      }
    }

    self.pass()
  }

  fn be_empty { |actual|
    let ok = actual.size() == 0

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} not to be empty")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be empty")
      }
    }

    self.pass()
  }

  fn be_of_type { |actual, expected_type|
    let t = typeof(actual)
    let ok = t == expected_type

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be of type {inspect(expected_type)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be of type {expected_type}, but got {t}")
      }
    }

    self.pass()
  }

  fn pass do {ok: true, message: ""}
  fn fail do {ok: false, message: it}
}


TestRunner().
  describe("Lit Array", fn { |t|
    t.test("#is_empty? when array is empty", fn { |should|
      [].is_empty?() |> should.eq(true)
    })
    t.test("#is_empty? when array is not empty", fn { |should|
      [1].is_empty?() |> should.eq(false)
    })
    t.test("#first when array is empty", fn { |should|
      [].first() |> should.eq(nil)
    })
    t.test("#first when array is not empty", fn { |should|
      [1].first() |> should.eq(1)
    })
    t.test("#sample returns a random element of the array", fn { |should|
      let array = [1, 2, 3, 4, 5]
      array.sample() |> should.be_in(array)
    })
  }).
  describe("Lit Float", fn { |t|
    t.test("#is_positive? when number is greater than 0", fn { |should|
      5.0.is_positive?() |> should.eq(true)
    })
    t.test("#is_positive? when number is less than 0", fn { |should|
      (-5.0).is_positive?() |> should.eq(false)
    })
    t.test("#is_positive? when number is 0", fn { |should|
      0.0.is_positive?() |> should.eq(false)
    })
    t.test("#to_i returns the integer value of the float", fn { |should|
      1.9999.to_i() |> should.eq(1)
    })
    t.test("#to_s returns the string value of the float", fn { |should|
      1.9999.to_s() |> should.eq("1.9999")
    })
    t.test("#truncate returns the float number truncated to a given precision", fn { |should|
      1.2345.truncate(2) |> should.eq(1.23)
    })
  }).
  describe("Lit Integer", fn { |t|
    t.test("#is_positive? when number is greater than 0", fn { |should|
      5.is_positive?() |> should.eq(true)
    })
    t.test("#is_positive? when number is less than 0", fn { |should|
      (-5).is_positive?() |> should.eq(false)
    })
    t.test("#is_positive? when number is 0", fn { |should|
      0.is_positive?() |> should.eq(false)
    })
    t.test("#to_f returns the float value of the integer", fn { |should|
      1.to_f() |> should.eq(1.0)
    })
    t.test("#to_s returns the string value of the number", fn { |should|
      42.to_s() |> should.eq("42")
    })
    t.test("#digits returns the digits of the number as an array", fn { |should|
      1234.digits() |> should.eq([4, 3, 2, 1])
    })
    t.test("#chr returns the character representation of the integer", fn { |should|
      65.chr() |> should.eq("A")
    })
    t.test("#times runs the given block n times", fn { |should|
      let arr = []

      3.times(fn { |i|
        arr.push(i)
      })

      arr |> should.eq([0, 1, 2])
    })
  }).
  describe("Lit Float", fn { |t|
    t.test("#is_positive? when number is greater than 0", fn { |should|
      5.0.is_positive?() |> should.eq(true)
    })
    t.test("#is_positive? when number is less than 0", fn { |should|
      (-5.0).is_positive?() |> should.eq(false)
    })
    t.test("#is_positive? when number is 0", fn { |should|
      0.0.is_positive?() |> should.eq(false)
    })
    t.test("#to_i returns the integer value of the float", fn { |should|
      1.9999.to_i() |> should.eq(1)
    })
    t.test("#to_s returns the string value of the float", fn { |should|
      1.9999.to_s() |> should.eq("1.9999")
    })
  }).
  describe("Lit String", fn { |t|
    t.test("#chars returns the individual characters of the string", fn { |should|
      "Hi, there!".chars() |> should.eq(["H", "i", ",", " ", "t", "h", "e", "r", "e", "!"])
    })
    t.test("#bytes returns the individual bytes of the string", fn { |should|
      "Abc".bytes() |> should.eq([65, 98, 99])
    })
    t.test("#chomp removes the trailing newline character", fn { |should|
      "Abc\n".chomp() |> should.eq("Abc")
    })
    t.test("#is_ascii_only? returns true for ASCII strings", fn { |should|
      "Abc".is_ascii_only?() |> should.eq(true)
    })
    t.test("#is_ascii_only? returns false for non-ASCII strings", fn { |should|
      "OlÃ¡".is_ascii_only?() |> should.eq(false)
    })
    t.test("#repeat returns the string repeated n times", fn { |should|
      "Hue".repeat(3) |> should.eq("HueHueHue")
    })
    t.test("#split without a param splits the string by whitespace", fn { |should|
      "abc".split() |> should.eq(["a", "b", "c"])
    })
    t.test("#split with a delimiter splits the string by the delimiter", fn { |should|
      "a,b,c".split(",") |> should.eq(["a", "b", "c"])
    })
    t.test("#to_i converts the numeric prefix of a string to an integer", fn { |should|
      "123asdf".to_i() |> should.eq(123)
    })
    t.test("#to_i returns 0 for invalid strings", fn { |should|
      "abc".to_i() |> should.eq(0)
    })
    t.test("#to_f converts the numeric prefix of a string to a float", fn { |should|
      "123.45asdf".to_f() |> should.eq(123.45)
    })
    t.test("#to_f returns 0.0 for invalid strings", fn { |should|
      "foo".to_f() |> should.eq(0.0)
    })
    t.test("#to_s returns self", fn { |should|
      let s = "foo"
      s.to_s() |> should.eq(s)
    })
    t.test("#includes? returns true if the string includes a substring", fn { |should|
      "foo".includes?("o") |> should.eq(true)
    })
    t.test("#includes? returns false if the string does not include a substring", fn { |should|
      "foo".includes?("x") |> should.eq(false)
    })
  }).
  run()
