type TestRunner {
  init {
    self.tests = []
    self.current_group = nil
  }

  fn test { |name, block|
    self.tests.push({ name: name, block: block })
  }

  fn describe { |group_name, group_block|
    self.current_group = group_name
    group_block(self)
    self
  }

  fn run {
    let start_time = clock()
    var failed_tests = []
    var tests_without_assertions = []

    self.tests.each(fn { |t|
      let result = t[:block](Should())

      if result && result[:ok] == false {
        print("F")
        failed_tests.push({ name: "{self.current_group} {t[:name]}", message: result[:message] })
      } else {
        if result {
          print(".")
        } else {
          print("?")
          tests_without_assertions.push(t[:name])
        }
      }
    })

    println()

    failed_tests.each(fn { |f|
      println()
      println("{f[:name]}:")
      println("  {f[:message]}")
    })
    let end_time = clock()
    let elapsed = end_time - start_time
    var total_time = if elapsed < 1 {
      "{(elapsed * 1000).truncate(2)} milliseconds"
      } else {
        "{elapsed.truncate(2)} seconds"
      }

    println()
    println("Finished in {total_time}")
    print("{self.tests.size()} examples, {failed_tests.size()} failures")
    if tests_without_assertions.size() > 0 {
      println(", {tests_without_assertions.size()} without assertions")
    } else {
      println()
    }

    if !failed_tests.is_empty?() do exit(1)
  }
}

type Should {
  init {
    self.negated = false
  }

  fn not {
    let s = Should()
    s.negated = !self.negated

    s
  }

  fn eq { |actual, expected|
    let ok = actual == expected

    if self.negated {
      if ok {
        return self.fail("Did not expect {inspect(expected)}, but got {inspect(actual)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(expected)}, but got {inspect(actual)}")
      }
    }

    self.pass()
  }

  fn greater_than { |actual, value|
    let ok = actual > value

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be greater than {inspect(value)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be greater than {inspect(value)}")
      }
    }

    self.pass()
  }

  fn greater_than_or_equal { |actual, value|
    let ok = actual >= value

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be >= {inspect(value)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be >= {inspect(value)}")
      }
    }

    self.pass()
  }

  fn less_than { |actual, value|
    let ok = actual < value

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be less than {inspect(value)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be less than {inspect(value)}")
      }
    }

    self.pass()
  }

  fn less_than_or_equal { |actual, value|
    let ok = actual <= value

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be <= {inspect(value)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be <= {inspect(value)}")
      }
    }

    self.pass()
  }

  fn be_in { |item, collection|
    self.include(collection, item)
  }

  fn include { |collection, item|
    let ok = collection.includes?(item)

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(collection)} to not include {inspect(item)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(collection)} to include {inspect(item)}")
      }
    }

    self.pass()
  }

  fn have_size { |actual, expected_size|
    let len = actual.size()
    let ok = len == expected_size

    if self.negated {
      if ok {
        return self.fail("Expected size to not be {expected_size}, but got {len}")
      }
    } else {
      if !ok {
        return self.fail("Expected size {expected_size}, got {len}")
      }
    }

    self.pass()
  }

  fn be_empty { |actual|
    let ok = actual.size() == 0

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} not to be empty")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be empty")
      }
    }

    self.pass()
  }

  fn be_of_type { |actual, expected_type|
    let t = typeof(actual)
    let ok = t == expected_type

    if self.negated {
      if ok {
        return self.fail("Expected {inspect(actual)} to not be of type {inspect(expected_type)}")
      }
    } else {
      if !ok {
        return self.fail("Expected {inspect(actual)} to be of type {expected_type}, but got {t}")
      }
    }

    self.pass()
  }

  fn pass do {ok: true, message: ""}
  fn fail do {ok: false, message: it}
}
