let Enum = {
  # fn each(enumerable, fun) {
  #   while let next = enumerable.next!() {
  #     fun(next)
  #   }
  # }

  fn is_empty?(enumerable) {
    enumerable == self.init()
  }

  fn map(enumerable, fun) {
    let acc = enumerable.type.init()

    enumerable.each { |value|
      acc << fun(value)
    }

    acc
  }

  fn filter(enumerable, fun) {
    let acc = enumerable.init()

    enumerable.each { |value|
      if fun(value) {
        acc << value
      }
    }

    acc
  }
}

type * {
  fn tap(f){
    f(self)

    self
  }
}

1.tap { println(it) }

type Array {
  fn each([], _fun) { self }
  fn each([head, ...tail], fun) {
    fun(head)
    self.each(tail, fun)
  }
  ...Enum
}

type HashMap {
  fn each({}, _fun) { self }
  fn each({key: value, ...tail}, fun) {
    fun([key, value])
    self.each(tail, fun)
  }
  ...Enum
}

Array.map([1, 2, 3]) { |x| x * 2 } |> Array.each { println(it) } # 2 4 6

[1, 2, 3].map { |x| x * 2 }.each { println(it) } # 2 4 6


struct List {
  fn new() {
    self.vals = []
  }

  fn push(val) {
    self.vals = [val, self.vals]
  }

  fn init() {
    List.new()
  }

  fn each(fun) {
    if !self.is_empty?() {
      [head, ...tail] = self.vals

      fun(head)
      tail.each(fun)
    }
  }
  ...Enum
}
